<!-- shop.html -->
<div class="vista-window">
  <div class="floating-image">
    <img src="/images/assets/pxldrm.png" alt="Floating decoration">
  </div>
  <div class="window-title-bar">
    <span class="window-title">clutter x Shop</span>
    <div class="window-controls">
      <button class="window-minimize">_</button>
      <button class="window-maximize">â–¡</button>
      <button class="window-close"></button>
    </div>
  </div>
  <div class="window-content">
    <h2>xEmpety A4x</h2>
    <p>!xtrivially truex!</p> 
    <p>Dream cellar. Selling a dream? Dream seller?</p>
    
    <div style="text-align: center; margin-top: 20px;">
      <a href="https://www.instagram.com/cluttercore/" target="_blank" class="instagram-icon" style="display: inline-block; transition: transform 0.3s ease;">
        <svg width="40" height="40" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: block;">
          <path d="M12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16Z" fill="url(#insta-gradient)" stroke="#000" stroke-width="1.5"/>
          <path d="M16.5 6H7.5C6.67157 6 6 6.67157 6 7.5V16.5C6 17.3284 6.67157 18 7.5 18H16.5C17.3284 18 18 17.3284 18 16.5V7.5C18 6.67157 17.3284 6 16.5 6Z" stroke="url(#insta-gradient)" stroke-width="1.5"/>
          <path d="M16.5 9.5V9.51" stroke="#fff" stroke-width="1.5" stroke-linecap="round"/>
          <defs>
            <linearGradient id="insta-gradient" x1="6" y1="6" x2="18" y2="18" gradientUnits="userSpaceOnUse">
              <stop stop-color="#833AB4"/>
              <stop offset="0.5" stop-color="#E1306C"/>
              <stop offset="1" stop-color="#F77737"/>
            </linearGradient>
          </defs>
        </svg>
      </a>
      <style>
        .instagram-icon:hover {
          transform: scale(1.2) rotate(8deg);
        }
      </style>
    </div>
  </div>
</div>

<style>
.vista-window {
  transition: transform 0.2s ease;
  cursor: move;
}

.vista-window.detached {
  box-shadow: 0 10px 30px rgba(0,0,0,0.3);
  border: 2px solid #00ff00;
}

.vista-window.detached .window-title-bar {
  background: linear-gradient(90deg, #00ff00, #0080ff);
}

/* Add shake animation for visual feedback */
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}

.vista-window.shaking {
  animation: shake 0.1s ease-in-out;
}
</style>

<script>
class WindowPhysics {
  constructor(windowElement) {
    this.window = windowElement;
    this.isDetached = false;
    this.isDragging = false;
    this.lastPositions = [];
    this.shakeThreshold = 15; // pixels
    this.shakeCount = 0;
    this.slamVelocityThreshold = 500; // pixels per second
    this.taskbarHeight = 60; // adjust based on your taskbar
    
    this.init();
  }

  init() {
    this.window.addEventListener('mousedown', this.startDrag.bind(this));
    document.addEventListener('mousemove', this.drag.bind(this));
    document.addEventListener('mouseup', this.endDrag.bind(this));
  }

  startDrag(e) {
    this.isDragging = true;
    this.lastPositions = [];
    this.shakeCount = 0;
    this.dragStartTime = Date.now();
    this.startY = e.clientY;
    
    // Record initial position for shake detection
    this.recordPosition(e.clientX, e.clientY);
  }

  drag(e) {
    if (!this.isDragging) return;
    
    this.recordPosition(e.clientX, e.clientY);
    
    if (this.isDetached) {
      // Free movement when detached
      this.moveWindowFreely(e.clientX, e.clientY);
    } else {
      // Constrained to taskbar rail when attached
      this.moveOnTaskbarRail(e.clientX, e.clientY);
      this.detectShake();
    }
  }

  endDrag(e) {
    if (!this.isDragging) return;
    this.isDragging = false;
    
    if (this.isDetached) {
      this.checkForSlamReattach(e);
    }
  }

  recordPosition(x, y) {
    this.lastPositions.push({ x, y, time: Date.now() });
    // Keep only last 10 positions for performance
    if (this.lastPositions.length > 10) {
      this.lastPositions.shift();
    }
  }

  detectShake() {
    if (this.lastPositions.length < 5) return;
    
    // Check for rapid up-down movement (shake)
    let verticalMovements = 0;
    for (let i = 1; i < this.lastPositions.length; i++) {
      const deltaY = Math.abs(this.lastPositions[i].y - this.lastPositions[i-1].y);
      if (deltaY > this.shakeThreshold) {
        verticalMovements++;
      }
    }
    
    // If enough vertical movement detected within short time
    if (verticalMovements >= 3) {
      this.detachWindow();
    }
  }

  detachWindow() {
    this.isDetached = true;
    this.window.classList.add('detached');
    this.window.style.zIndex = '9999';
    
    // Add visual feedback
    this.window.style.transform += ' scale(1.05)';
    setTimeout(() => {
      this.window.style.transform = this.window.style.transform.replace(' scale(1.05)', '');
    }, 200);
    
    // Trigger custom event
    this.window.dispatchEvent(new CustomEvent('windowDetached'));
  }

  checkForSlamReattach(e) {
    const windowBottom = this.window.getBoundingClientRect().bottom;
    const taskbarTop = window.innerHeight - this.taskbarHeight;
    
    // Check if window is near taskbar
    if (Math.abs(windowBottom - taskbarTop) < 50) {
      // Calculate slam velocity
      const velocity = this.calculateVelocity();
      
      if (velocity > this.slamVelocityThreshold) {
        this.reattachWindow();
      }
    }
  }

  calculateVelocity() {
    if (this.lastPositions.length < 2) return 0;
    
    const recent = this.lastPositions.slice(-3);
    let totalDistance = 0;
    let totalTime = 0;
    
    for (let i = 1; i < recent.length; i++) {
      const dx = recent[i].x - recent[i-1].x;
      const dy = recent[i].y - recent[i-1].y;
      const distance = Math.sqrt(dx*dx + dy*dy);
      const time = recent[i].time - recent[i-1].time;
      
      totalDistance += distance;
      totalTime += time;
    }
    
    return totalDistance / (totalTime || 1) * 1000; // pixels per second
  }

  reattachWindow() {
    this.isDetached = false;
    this.window.classList.remove('detached');
    this.window.style.zIndex = '';
    
    // Snap to taskbar
    this.snapToTaskbar();
    
    // Visual feedback
    this.window.style.transform += ' scale(0.95)';
    setTimeout(() => {
      this.window.style.transform = this.window.style.transform.replace(' scale(0.95)', '');
    }, 200);
    
    // Trigger custom event
    this.window.dispatchEvent(new CustomEvent('windowReattached'));
  }

  moveWindowFreely(x, y) {
    this.window.style.left = x + 'px';
    this.window.style.top = y + 'px';
    this.window.style.position = 'fixed';
  }

  moveOnTaskbarRail(x, y) {
    // Constrain to horizontal movement along taskbar
    const taskbarY = window.innerHeight - this.taskbarHeight - this.window.offsetHeight;
    this.window.style.left = x + 'px';
    this.window.style.top = taskbarY + 'px';
  }

  snapToTaskbar() {
    const taskbarY = window.innerHeight - this.taskbarHeight - this.window.offsetHeight;
    this.window.style.top = taskbarY + 'px';
    this.window.style.position = 'fixed';
  }
}

// Initialize physics for all windows
document.addEventListener('DOMContentLoaded', () => {
  const windows = document.querySelectorAll('.vista-window');
  windows.forEach(window => {
    new WindowPhysics(window);
  });
});
</script>
